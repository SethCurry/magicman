// Code generated by entc, DO NOT EDIT.

package card

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/SethCurry/magicman/pkg/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// MultiverseID applies equality check predicate on the "multiverse_id" field. It's identical to MultiverseIDEQ.
func MultiverseID(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMultiverseID), v))
	})
}

// GathererID applies equality check predicate on the "gatherer_id" field. It's identical to GathererIDEQ.
func GathererID(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGathererID), v))
	})
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// Type applies equality check predicate on the "type" field. It's identical to TypeEQ.
func Type(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType), v))
	})
}

// Text applies equality check predicate on the "text" field. It's identical to TextEQ.
func Text(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldText), v))
	})
}

// Cmc applies equality check predicate on the "cmc" field. It's identical to CmcEQ.
func Cmc(v int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCmc), v))
	})
}

// ManaCost applies equality check predicate on the "mana_cost" field. It's identical to ManaCostEQ.
func ManaCost(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldManaCost), v))
	})
}

// Artist applies equality check predicate on the "artist" field. It's identical to ArtistEQ.
func Artist(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldArtist), v))
	})
}

// Power applies equality check predicate on the "power" field. It's identical to PowerEQ.
func Power(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPower), v))
	})
}

// Toughness applies equality check predicate on the "toughness" field. It's identical to ToughnessEQ.
func Toughness(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToughness), v))
	})
}

// ImageURL applies equality check predicate on the "image_url" field. It's identical to ImageURLEQ.
func ImageURL(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldImageURL), v))
	})
}

// OriginalText applies equality check predicate on the "original_text" field. It's identical to OriginalTextEQ.
func OriginalText(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOriginalText), v))
	})
}

// OriginalType applies equality check predicate on the "original_type" field. It's identical to OriginalTypeEQ.
func OriginalType(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOriginalType), v))
	})
}

// CachedImagePath applies equality check predicate on the "cached_image_path" field. It's identical to CachedImagePathEQ.
func CachedImagePath(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCachedImagePath), v))
	})
}

// Rarity applies equality check predicate on the "rarity" field. It's identical to RarityEQ.
func Rarity(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRarity), v))
	})
}

// MultiverseIDEQ applies the EQ predicate on the "multiverse_id" field.
func MultiverseIDEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDNEQ applies the NEQ predicate on the "multiverse_id" field.
func MultiverseIDNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDIn applies the In predicate on the "multiverse_id" field.
func MultiverseIDIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMultiverseID), v...))
	})
}

// MultiverseIDNotIn applies the NotIn predicate on the "multiverse_id" field.
func MultiverseIDNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMultiverseID), v...))
	})
}

// MultiverseIDGT applies the GT predicate on the "multiverse_id" field.
func MultiverseIDGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDGTE applies the GTE predicate on the "multiverse_id" field.
func MultiverseIDGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDLT applies the LT predicate on the "multiverse_id" field.
func MultiverseIDLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDLTE applies the LTE predicate on the "multiverse_id" field.
func MultiverseIDLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDContains applies the Contains predicate on the "multiverse_id" field.
func MultiverseIDContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDHasPrefix applies the HasPrefix predicate on the "multiverse_id" field.
func MultiverseIDHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDHasSuffix applies the HasSuffix predicate on the "multiverse_id" field.
func MultiverseIDHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDEqualFold applies the EqualFold predicate on the "multiverse_id" field.
func MultiverseIDEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMultiverseID), v))
	})
}

// MultiverseIDContainsFold applies the ContainsFold predicate on the "multiverse_id" field.
func MultiverseIDContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMultiverseID), v))
	})
}

// GathererIDEQ applies the EQ predicate on the "gatherer_id" field.
func GathererIDEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGathererID), v))
	})
}

// GathererIDNEQ applies the NEQ predicate on the "gatherer_id" field.
func GathererIDNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGathererID), v))
	})
}

// GathererIDIn applies the In predicate on the "gatherer_id" field.
func GathererIDIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGathererID), v...))
	})
}

// GathererIDNotIn applies the NotIn predicate on the "gatherer_id" field.
func GathererIDNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGathererID), v...))
	})
}

// GathererIDGT applies the GT predicate on the "gatherer_id" field.
func GathererIDGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGathererID), v))
	})
}

// GathererIDGTE applies the GTE predicate on the "gatherer_id" field.
func GathererIDGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGathererID), v))
	})
}

// GathererIDLT applies the LT predicate on the "gatherer_id" field.
func GathererIDLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGathererID), v))
	})
}

// GathererIDLTE applies the LTE predicate on the "gatherer_id" field.
func GathererIDLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGathererID), v))
	})
}

// GathererIDContains applies the Contains predicate on the "gatherer_id" field.
func GathererIDContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGathererID), v))
	})
}

// GathererIDHasPrefix applies the HasPrefix predicate on the "gatherer_id" field.
func GathererIDHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGathererID), v))
	})
}

// GathererIDHasSuffix applies the HasSuffix predicate on the "gatherer_id" field.
func GathererIDHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGathererID), v))
	})
}

// GathererIDEqualFold applies the EqualFold predicate on the "gatherer_id" field.
func GathererIDEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGathererID), v))
	})
}

// GathererIDContainsFold applies the ContainsFold predicate on the "gatherer_id" field.
func GathererIDContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGathererID), v))
	})
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldName), v))
	})
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldName), v...))
	})
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldName), v...))
	})
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldName), v))
	})
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldName), v))
	})
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldName), v))
	})
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldName), v))
	})
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldName), v))
	})
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldName), v))
	})
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldName), v))
	})
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldName), v))
	})
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldName), v))
	})
}

// TypeEQ applies the EQ predicate on the "type" field.
func TypeEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType), v))
	})
}

// TypeNEQ applies the NEQ predicate on the "type" field.
func TypeNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldType), v))
	})
}

// TypeIn applies the In predicate on the "type" field.
func TypeIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldType), v...))
	})
}

// TypeNotIn applies the NotIn predicate on the "type" field.
func TypeNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldType), v...))
	})
}

// TypeGT applies the GT predicate on the "type" field.
func TypeGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldType), v))
	})
}

// TypeGTE applies the GTE predicate on the "type" field.
func TypeGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldType), v))
	})
}

// TypeLT applies the LT predicate on the "type" field.
func TypeLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldType), v))
	})
}

// TypeLTE applies the LTE predicate on the "type" field.
func TypeLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldType), v))
	})
}

// TypeContains applies the Contains predicate on the "type" field.
func TypeContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldType), v))
	})
}

// TypeHasPrefix applies the HasPrefix predicate on the "type" field.
func TypeHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldType), v))
	})
}

// TypeHasSuffix applies the HasSuffix predicate on the "type" field.
func TypeHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldType), v))
	})
}

// TypeEqualFold applies the EqualFold predicate on the "type" field.
func TypeEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldType), v))
	})
}

// TypeContainsFold applies the ContainsFold predicate on the "type" field.
func TypeContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldType), v))
	})
}

// TextEQ applies the EQ predicate on the "text" field.
func TextEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldText), v))
	})
}

// TextNEQ applies the NEQ predicate on the "text" field.
func TextNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldText), v))
	})
}

// TextIn applies the In predicate on the "text" field.
func TextIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldText), v...))
	})
}

// TextNotIn applies the NotIn predicate on the "text" field.
func TextNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldText), v...))
	})
}

// TextGT applies the GT predicate on the "text" field.
func TextGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldText), v))
	})
}

// TextGTE applies the GTE predicate on the "text" field.
func TextGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldText), v))
	})
}

// TextLT applies the LT predicate on the "text" field.
func TextLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldText), v))
	})
}

// TextLTE applies the LTE predicate on the "text" field.
func TextLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldText), v))
	})
}

// TextContains applies the Contains predicate on the "text" field.
func TextContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldText), v))
	})
}

// TextHasPrefix applies the HasPrefix predicate on the "text" field.
func TextHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldText), v))
	})
}

// TextHasSuffix applies the HasSuffix predicate on the "text" field.
func TextHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldText), v))
	})
}

// TextEqualFold applies the EqualFold predicate on the "text" field.
func TextEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldText), v))
	})
}

// TextContainsFold applies the ContainsFold predicate on the "text" field.
func TextContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldText), v))
	})
}

// CmcEQ applies the EQ predicate on the "cmc" field.
func CmcEQ(v int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCmc), v))
	})
}

// CmcNEQ applies the NEQ predicate on the "cmc" field.
func CmcNEQ(v int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCmc), v))
	})
}

// CmcIn applies the In predicate on the "cmc" field.
func CmcIn(vs ...int) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCmc), v...))
	})
}

// CmcNotIn applies the NotIn predicate on the "cmc" field.
func CmcNotIn(vs ...int) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCmc), v...))
	})
}

// CmcGT applies the GT predicate on the "cmc" field.
func CmcGT(v int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCmc), v))
	})
}

// CmcGTE applies the GTE predicate on the "cmc" field.
func CmcGTE(v int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCmc), v))
	})
}

// CmcLT applies the LT predicate on the "cmc" field.
func CmcLT(v int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCmc), v))
	})
}

// CmcLTE applies the LTE predicate on the "cmc" field.
func CmcLTE(v int) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCmc), v))
	})
}

// ManaCostEQ applies the EQ predicate on the "mana_cost" field.
func ManaCostEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldManaCost), v))
	})
}

// ManaCostNEQ applies the NEQ predicate on the "mana_cost" field.
func ManaCostNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldManaCost), v))
	})
}

// ManaCostIn applies the In predicate on the "mana_cost" field.
func ManaCostIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldManaCost), v...))
	})
}

// ManaCostNotIn applies the NotIn predicate on the "mana_cost" field.
func ManaCostNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldManaCost), v...))
	})
}

// ManaCostGT applies the GT predicate on the "mana_cost" field.
func ManaCostGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldManaCost), v))
	})
}

// ManaCostGTE applies the GTE predicate on the "mana_cost" field.
func ManaCostGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldManaCost), v))
	})
}

// ManaCostLT applies the LT predicate on the "mana_cost" field.
func ManaCostLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldManaCost), v))
	})
}

// ManaCostLTE applies the LTE predicate on the "mana_cost" field.
func ManaCostLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldManaCost), v))
	})
}

// ManaCostContains applies the Contains predicate on the "mana_cost" field.
func ManaCostContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldManaCost), v))
	})
}

// ManaCostHasPrefix applies the HasPrefix predicate on the "mana_cost" field.
func ManaCostHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldManaCost), v))
	})
}

// ManaCostHasSuffix applies the HasSuffix predicate on the "mana_cost" field.
func ManaCostHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldManaCost), v))
	})
}

// ManaCostEqualFold applies the EqualFold predicate on the "mana_cost" field.
func ManaCostEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldManaCost), v))
	})
}

// ManaCostContainsFold applies the ContainsFold predicate on the "mana_cost" field.
func ManaCostContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldManaCost), v))
	})
}

// ArtistEQ applies the EQ predicate on the "artist" field.
func ArtistEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldArtist), v))
	})
}

// ArtistNEQ applies the NEQ predicate on the "artist" field.
func ArtistNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldArtist), v))
	})
}

// ArtistIn applies the In predicate on the "artist" field.
func ArtistIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldArtist), v...))
	})
}

// ArtistNotIn applies the NotIn predicate on the "artist" field.
func ArtistNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldArtist), v...))
	})
}

// ArtistGT applies the GT predicate on the "artist" field.
func ArtistGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldArtist), v))
	})
}

// ArtistGTE applies the GTE predicate on the "artist" field.
func ArtistGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldArtist), v))
	})
}

// ArtistLT applies the LT predicate on the "artist" field.
func ArtistLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldArtist), v))
	})
}

// ArtistLTE applies the LTE predicate on the "artist" field.
func ArtistLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldArtist), v))
	})
}

// ArtistContains applies the Contains predicate on the "artist" field.
func ArtistContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldArtist), v))
	})
}

// ArtistHasPrefix applies the HasPrefix predicate on the "artist" field.
func ArtistHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldArtist), v))
	})
}

// ArtistHasSuffix applies the HasSuffix predicate on the "artist" field.
func ArtistHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldArtist), v))
	})
}

// ArtistEqualFold applies the EqualFold predicate on the "artist" field.
func ArtistEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldArtist), v))
	})
}

// ArtistContainsFold applies the ContainsFold predicate on the "artist" field.
func ArtistContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldArtist), v))
	})
}

// PowerEQ applies the EQ predicate on the "power" field.
func PowerEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPower), v))
	})
}

// PowerNEQ applies the NEQ predicate on the "power" field.
func PowerNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPower), v))
	})
}

// PowerIn applies the In predicate on the "power" field.
func PowerIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPower), v...))
	})
}

// PowerNotIn applies the NotIn predicate on the "power" field.
func PowerNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPower), v...))
	})
}

// PowerGT applies the GT predicate on the "power" field.
func PowerGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPower), v))
	})
}

// PowerGTE applies the GTE predicate on the "power" field.
func PowerGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPower), v))
	})
}

// PowerLT applies the LT predicate on the "power" field.
func PowerLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPower), v))
	})
}

// PowerLTE applies the LTE predicate on the "power" field.
func PowerLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPower), v))
	})
}

// PowerContains applies the Contains predicate on the "power" field.
func PowerContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPower), v))
	})
}

// PowerHasPrefix applies the HasPrefix predicate on the "power" field.
func PowerHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPower), v))
	})
}

// PowerHasSuffix applies the HasSuffix predicate on the "power" field.
func PowerHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPower), v))
	})
}

// PowerEqualFold applies the EqualFold predicate on the "power" field.
func PowerEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPower), v))
	})
}

// PowerContainsFold applies the ContainsFold predicate on the "power" field.
func PowerContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPower), v))
	})
}

// ToughnessEQ applies the EQ predicate on the "toughness" field.
func ToughnessEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToughness), v))
	})
}

// ToughnessNEQ applies the NEQ predicate on the "toughness" field.
func ToughnessNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldToughness), v))
	})
}

// ToughnessIn applies the In predicate on the "toughness" field.
func ToughnessIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldToughness), v...))
	})
}

// ToughnessNotIn applies the NotIn predicate on the "toughness" field.
func ToughnessNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldToughness), v...))
	})
}

// ToughnessGT applies the GT predicate on the "toughness" field.
func ToughnessGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldToughness), v))
	})
}

// ToughnessGTE applies the GTE predicate on the "toughness" field.
func ToughnessGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldToughness), v))
	})
}

// ToughnessLT applies the LT predicate on the "toughness" field.
func ToughnessLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldToughness), v))
	})
}

// ToughnessLTE applies the LTE predicate on the "toughness" field.
func ToughnessLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldToughness), v))
	})
}

// ToughnessContains applies the Contains predicate on the "toughness" field.
func ToughnessContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldToughness), v))
	})
}

// ToughnessHasPrefix applies the HasPrefix predicate on the "toughness" field.
func ToughnessHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldToughness), v))
	})
}

// ToughnessHasSuffix applies the HasSuffix predicate on the "toughness" field.
func ToughnessHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldToughness), v))
	})
}

// ToughnessEqualFold applies the EqualFold predicate on the "toughness" field.
func ToughnessEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldToughness), v))
	})
}

// ToughnessContainsFold applies the ContainsFold predicate on the "toughness" field.
func ToughnessContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldToughness), v))
	})
}

// ImageURLEQ applies the EQ predicate on the "image_url" field.
func ImageURLEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldImageURL), v))
	})
}

// ImageURLNEQ applies the NEQ predicate on the "image_url" field.
func ImageURLNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldImageURL), v))
	})
}

// ImageURLIn applies the In predicate on the "image_url" field.
func ImageURLIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldImageURL), v...))
	})
}

// ImageURLNotIn applies the NotIn predicate on the "image_url" field.
func ImageURLNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldImageURL), v...))
	})
}

// ImageURLGT applies the GT predicate on the "image_url" field.
func ImageURLGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldImageURL), v))
	})
}

// ImageURLGTE applies the GTE predicate on the "image_url" field.
func ImageURLGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldImageURL), v))
	})
}

// ImageURLLT applies the LT predicate on the "image_url" field.
func ImageURLLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldImageURL), v))
	})
}

// ImageURLLTE applies the LTE predicate on the "image_url" field.
func ImageURLLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldImageURL), v))
	})
}

// ImageURLContains applies the Contains predicate on the "image_url" field.
func ImageURLContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldImageURL), v))
	})
}

// ImageURLHasPrefix applies the HasPrefix predicate on the "image_url" field.
func ImageURLHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldImageURL), v))
	})
}

// ImageURLHasSuffix applies the HasSuffix predicate on the "image_url" field.
func ImageURLHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldImageURL), v))
	})
}

// ImageURLEqualFold applies the EqualFold predicate on the "image_url" field.
func ImageURLEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldImageURL), v))
	})
}

// ImageURLContainsFold applies the ContainsFold predicate on the "image_url" field.
func ImageURLContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldImageURL), v))
	})
}

// OriginalTextEQ applies the EQ predicate on the "original_text" field.
func OriginalTextEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOriginalText), v))
	})
}

// OriginalTextNEQ applies the NEQ predicate on the "original_text" field.
func OriginalTextNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOriginalText), v))
	})
}

// OriginalTextIn applies the In predicate on the "original_text" field.
func OriginalTextIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOriginalText), v...))
	})
}

// OriginalTextNotIn applies the NotIn predicate on the "original_text" field.
func OriginalTextNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOriginalText), v...))
	})
}

// OriginalTextGT applies the GT predicate on the "original_text" field.
func OriginalTextGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOriginalText), v))
	})
}

// OriginalTextGTE applies the GTE predicate on the "original_text" field.
func OriginalTextGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOriginalText), v))
	})
}

// OriginalTextLT applies the LT predicate on the "original_text" field.
func OriginalTextLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOriginalText), v))
	})
}

// OriginalTextLTE applies the LTE predicate on the "original_text" field.
func OriginalTextLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOriginalText), v))
	})
}

// OriginalTextContains applies the Contains predicate on the "original_text" field.
func OriginalTextContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldOriginalText), v))
	})
}

// OriginalTextHasPrefix applies the HasPrefix predicate on the "original_text" field.
func OriginalTextHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldOriginalText), v))
	})
}

// OriginalTextHasSuffix applies the HasSuffix predicate on the "original_text" field.
func OriginalTextHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldOriginalText), v))
	})
}

// OriginalTextEqualFold applies the EqualFold predicate on the "original_text" field.
func OriginalTextEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldOriginalText), v))
	})
}

// OriginalTextContainsFold applies the ContainsFold predicate on the "original_text" field.
func OriginalTextContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldOriginalText), v))
	})
}

// OriginalTypeEQ applies the EQ predicate on the "original_type" field.
func OriginalTypeEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeNEQ applies the NEQ predicate on the "original_type" field.
func OriginalTypeNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeIn applies the In predicate on the "original_type" field.
func OriginalTypeIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOriginalType), v...))
	})
}

// OriginalTypeNotIn applies the NotIn predicate on the "original_type" field.
func OriginalTypeNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOriginalType), v...))
	})
}

// OriginalTypeGT applies the GT predicate on the "original_type" field.
func OriginalTypeGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeGTE applies the GTE predicate on the "original_type" field.
func OriginalTypeGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeLT applies the LT predicate on the "original_type" field.
func OriginalTypeLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeLTE applies the LTE predicate on the "original_type" field.
func OriginalTypeLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeContains applies the Contains predicate on the "original_type" field.
func OriginalTypeContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeHasPrefix applies the HasPrefix predicate on the "original_type" field.
func OriginalTypeHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeHasSuffix applies the HasSuffix predicate on the "original_type" field.
func OriginalTypeHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeEqualFold applies the EqualFold predicate on the "original_type" field.
func OriginalTypeEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldOriginalType), v))
	})
}

// OriginalTypeContainsFold applies the ContainsFold predicate on the "original_type" field.
func OriginalTypeContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldOriginalType), v))
	})
}

// CachedImagePathEQ applies the EQ predicate on the "cached_image_path" field.
func CachedImagePathEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathNEQ applies the NEQ predicate on the "cached_image_path" field.
func CachedImagePathNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathIn applies the In predicate on the "cached_image_path" field.
func CachedImagePathIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCachedImagePath), v...))
	})
}

// CachedImagePathNotIn applies the NotIn predicate on the "cached_image_path" field.
func CachedImagePathNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCachedImagePath), v...))
	})
}

// CachedImagePathGT applies the GT predicate on the "cached_image_path" field.
func CachedImagePathGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathGTE applies the GTE predicate on the "cached_image_path" field.
func CachedImagePathGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathLT applies the LT predicate on the "cached_image_path" field.
func CachedImagePathLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathLTE applies the LTE predicate on the "cached_image_path" field.
func CachedImagePathLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathContains applies the Contains predicate on the "cached_image_path" field.
func CachedImagePathContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathHasPrefix applies the HasPrefix predicate on the "cached_image_path" field.
func CachedImagePathHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathHasSuffix applies the HasSuffix predicate on the "cached_image_path" field.
func CachedImagePathHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathIsNil applies the IsNil predicate on the "cached_image_path" field.
func CachedImagePathIsNil() predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCachedImagePath)))
	})
}

// CachedImagePathNotNil applies the NotNil predicate on the "cached_image_path" field.
func CachedImagePathNotNil() predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCachedImagePath)))
	})
}

// CachedImagePathEqualFold applies the EqualFold predicate on the "cached_image_path" field.
func CachedImagePathEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCachedImagePath), v))
	})
}

// CachedImagePathContainsFold applies the ContainsFold predicate on the "cached_image_path" field.
func CachedImagePathContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCachedImagePath), v))
	})
}

// RarityEQ applies the EQ predicate on the "rarity" field.
func RarityEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRarity), v))
	})
}

// RarityNEQ applies the NEQ predicate on the "rarity" field.
func RarityNEQ(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRarity), v))
	})
}

// RarityIn applies the In predicate on the "rarity" field.
func RarityIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRarity), v...))
	})
}

// RarityNotIn applies the NotIn predicate on the "rarity" field.
func RarityNotIn(vs ...string) predicate.Card {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Card(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRarity), v...))
	})
}

// RarityGT applies the GT predicate on the "rarity" field.
func RarityGT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRarity), v))
	})
}

// RarityGTE applies the GTE predicate on the "rarity" field.
func RarityGTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRarity), v))
	})
}

// RarityLT applies the LT predicate on the "rarity" field.
func RarityLT(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRarity), v))
	})
}

// RarityLTE applies the LTE predicate on the "rarity" field.
func RarityLTE(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRarity), v))
	})
}

// RarityContains applies the Contains predicate on the "rarity" field.
func RarityContains(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRarity), v))
	})
}

// RarityHasPrefix applies the HasPrefix predicate on the "rarity" field.
func RarityHasPrefix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRarity), v))
	})
}

// RarityHasSuffix applies the HasSuffix predicate on the "rarity" field.
func RarityHasSuffix(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRarity), v))
	})
}

// RarityEqualFold applies the EqualFold predicate on the "rarity" field.
func RarityEqualFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRarity), v))
	})
}

// RarityContainsFold applies the ContainsFold predicate on the "rarity" field.
func RarityContainsFold(v string) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRarity), v))
	})
}

// HasRulings applies the HasEdge predicate on the "rulings" edge.
func HasRulings() predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(RulingsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, RulingsTable, RulingsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasRulingsWith applies the HasEdge predicate on the "rulings" edge with a given conditions (other predicates).
func HasRulingsWith(preds ...predicate.Ruling) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(RulingsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, RulingsTable, RulingsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasSet applies the HasEdge predicate on the "set" edge.
func HasSet() predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SetTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, SetTable, SetColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasSetWith applies the HasEdge predicate on the "set" edge with a given conditions (other predicates).
func HasSetWith(preds ...predicate.Set) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SetInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, SetTable, SetColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasTypes applies the HasEdge predicate on the "types" edge.
func HasTypes() predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TypesTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, TypesTable, TypesPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTypesWith applies the HasEdge predicate on the "types" edge with a given conditions (other predicates).
func HasTypesWith(preds ...predicate.CardType) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TypesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, TypesTable, TypesPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasSubtypes applies the HasEdge predicate on the "subtypes" edge.
func HasSubtypes() predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SubtypesTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, SubtypesTable, SubtypesPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasSubtypesWith applies the HasEdge predicate on the "subtypes" edge with a given conditions (other predicates).
func HasSubtypesWith(preds ...predicate.SubType) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SubtypesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, SubtypesTable, SubtypesPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasSupertypes applies the HasEdge predicate on the "supertypes" edge.
func HasSupertypes() predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SupertypesTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, SupertypesTable, SupertypesPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasSupertypesWith applies the HasEdge predicate on the "supertypes" edge with a given conditions (other predicates).
func HasSupertypesWith(preds ...predicate.SuperType) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(SupertypesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, SupertypesTable, SupertypesPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasColors applies the HasEdge predicate on the "colors" edge.
func HasColors() predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ColorsTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, ColorsTable, ColorsPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasColorsWith applies the HasEdge predicate on the "colors" edge with a given conditions (other predicates).
func HasColorsWith(preds ...predicate.Color) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ColorsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, ColorsTable, ColorsPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasDeckCards applies the HasEdge predicate on the "deck_cards" edge.
func HasDeckCards() predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(DeckCardsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, DeckCardsTable, DeckCardsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasDeckCardsWith applies the HasEdge predicate on the "deck_cards" edge with a given conditions (other predicates).
func HasDeckCardsWith(preds ...predicate.DeckCard) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(DeckCardsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, DeckCardsTable, DeckCardsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Card) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Card) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Card) predicate.Card {
	return predicate.Card(func(s *sql.Selector) {
		p(s.Not())
	})
}
