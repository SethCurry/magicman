// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/SethCurry/magicman/pkg/ent/card"
	"github.com/SethCurry/magicman/pkg/ent/cardtype"
	"github.com/SethCurry/magicman/pkg/ent/color"
	"github.com/SethCurry/magicman/pkg/ent/deck"
	"github.com/SethCurry/magicman/pkg/ent/deckcard"
	"github.com/SethCurry/magicman/pkg/ent/predicate"
	"github.com/SethCurry/magicman/pkg/ent/ruling"
	"github.com/SethCurry/magicman/pkg/ent/set"
	"github.com/SethCurry/magicman/pkg/ent/subtype"
	"github.com/SethCurry/magicman/pkg/ent/supertype"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCard      = "Card"
	TypeCardType  = "CardType"
	TypeColor     = "Color"
	TypeDeck      = "Deck"
	TypeDeckCard  = "DeckCard"
	TypeRuling    = "Ruling"
	TypeSet       = "Set"
	TypeSubType   = "SubType"
	TypeSuperType = "SuperType"
)

// CardMutation represents an operation that mutates the Card nodes in the graph.
type CardMutation struct {
	config
	op                Op
	typ               string
	id                *int
	multiverse_id     *string
	gatherer_id       *string
	name              *string
	_type             *string
	text              *string
	cmc               *int
	addcmc            *int
	mana_cost         *string
	artist            *string
	power             *string
	toughness         *string
	image_url         *string
	original_text     *string
	original_type     *string
	cached_image_path *string
	rarity            *string
	clearedFields     map[string]struct{}
	rulings           map[int]struct{}
	removedrulings    map[int]struct{}
	clearedrulings    bool
	set               *int
	clearedset        bool
	types             map[int]struct{}
	removedtypes      map[int]struct{}
	clearedtypes      bool
	subtypes          map[int]struct{}
	removedsubtypes   map[int]struct{}
	clearedsubtypes   bool
	supertypes        map[int]struct{}
	removedsupertypes map[int]struct{}
	clearedsupertypes bool
	colors            map[int]struct{}
	removedcolors     map[int]struct{}
	clearedcolors     bool
	deck_cards        map[int]struct{}
	removeddeck_cards map[int]struct{}
	cleareddeck_cards bool
	done              bool
	oldValue          func(context.Context) (*Card, error)
	predicates        []predicate.Card
}

var _ ent.Mutation = (*CardMutation)(nil)

// cardOption allows management of the mutation configuration using functional options.
type cardOption func(*CardMutation)

// newCardMutation creates new mutation for the Card entity.
func newCardMutation(c config, op Op, opts ...cardOption) *CardMutation {
	m := &CardMutation{
		config:        c,
		op:            op,
		typ:           TypeCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardID sets the ID field of the mutation.
func withCardID(id int) cardOption {
	return func(m *CardMutation) {
		var (
			err   error
			once  sync.Once
			value *Card
		)
		m.oldValue = func(ctx context.Context) (*Card, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Card.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCard sets the old Card of the mutation.
func withCard(node *Card) cardOption {
	return func(m *CardMutation) {
		m.oldValue = func(context.Context) (*Card, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Card.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMultiverseID sets the "multiverse_id" field.
func (m *CardMutation) SetMultiverseID(s string) {
	m.multiverse_id = &s
}

// MultiverseID returns the value of the "multiverse_id" field in the mutation.
func (m *CardMutation) MultiverseID() (r string, exists bool) {
	v := m.multiverse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiverseID returns the old "multiverse_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldMultiverseID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiverseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiverseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiverseID: %w", err)
	}
	return oldValue.MultiverseID, nil
}

// ResetMultiverseID resets all changes to the "multiverse_id" field.
func (m *CardMutation) ResetMultiverseID() {
	m.multiverse_id = nil
}

// SetGathererID sets the "gatherer_id" field.
func (m *CardMutation) SetGathererID(s string) {
	m.gatherer_id = &s
}

// GathererID returns the value of the "gatherer_id" field in the mutation.
func (m *CardMutation) GathererID() (r string, exists bool) {
	v := m.gatherer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGathererID returns the old "gatherer_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldGathererID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGathererID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGathererID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGathererID: %w", err)
	}
	return oldValue.GathererID, nil
}

// ResetGathererID resets all changes to the "gatherer_id" field.
func (m *CardMutation) ResetGathererID() {
	m.gatherer_id = nil
}

// SetName sets the "name" field.
func (m *CardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CardMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *CardMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CardMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CardMutation) ResetType() {
	m._type = nil
}

// SetText sets the "text" field.
func (m *CardMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *CardMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *CardMutation) ResetText() {
	m.text = nil
}

// SetCmc sets the "cmc" field.
func (m *CardMutation) SetCmc(i int) {
	m.cmc = &i
	m.addcmc = nil
}

// Cmc returns the value of the "cmc" field in the mutation.
func (m *CardMutation) Cmc() (r int, exists bool) {
	v := m.cmc
	if v == nil {
		return
	}
	return *v, true
}

// OldCmc returns the old "cmc" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldCmc(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCmc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCmc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmc: %w", err)
	}
	return oldValue.Cmc, nil
}

// AddCmc adds i to the "cmc" field.
func (m *CardMutation) AddCmc(i int) {
	if m.addcmc != nil {
		*m.addcmc += i
	} else {
		m.addcmc = &i
	}
}

// AddedCmc returns the value that was added to the "cmc" field in this mutation.
func (m *CardMutation) AddedCmc() (r int, exists bool) {
	v := m.addcmc
	if v == nil {
		return
	}
	return *v, true
}

// ResetCmc resets all changes to the "cmc" field.
func (m *CardMutation) ResetCmc() {
	m.cmc = nil
	m.addcmc = nil
}

// SetManaCost sets the "mana_cost" field.
func (m *CardMutation) SetManaCost(s string) {
	m.mana_cost = &s
}

// ManaCost returns the value of the "mana_cost" field in the mutation.
func (m *CardMutation) ManaCost() (r string, exists bool) {
	v := m.mana_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldManaCost returns the old "mana_cost" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldManaCost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManaCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManaCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManaCost: %w", err)
	}
	return oldValue.ManaCost, nil
}

// ResetManaCost resets all changes to the "mana_cost" field.
func (m *CardMutation) ResetManaCost() {
	m.mana_cost = nil
}

// SetArtist sets the "artist" field.
func (m *CardMutation) SetArtist(s string) {
	m.artist = &s
}

// Artist returns the value of the "artist" field in the mutation.
func (m *CardMutation) Artist() (r string, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtist returns the old "artist" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldArtist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtist: %w", err)
	}
	return oldValue.Artist, nil
}

// ResetArtist resets all changes to the "artist" field.
func (m *CardMutation) ResetArtist() {
	m.artist = nil
}

// SetPower sets the "power" field.
func (m *CardMutation) SetPower(s string) {
	m.power = &s
}

// Power returns the value of the "power" field in the mutation.
func (m *CardMutation) Power() (r string, exists bool) {
	v := m.power
	if v == nil {
		return
	}
	return *v, true
}

// OldPower returns the old "power" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldPower(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPower is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPower requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPower: %w", err)
	}
	return oldValue.Power, nil
}

// ResetPower resets all changes to the "power" field.
func (m *CardMutation) ResetPower() {
	m.power = nil
}

// SetToughness sets the "toughness" field.
func (m *CardMutation) SetToughness(s string) {
	m.toughness = &s
}

// Toughness returns the value of the "toughness" field in the mutation.
func (m *CardMutation) Toughness() (r string, exists bool) {
	v := m.toughness
	if v == nil {
		return
	}
	return *v, true
}

// OldToughness returns the old "toughness" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldToughness(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToughness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToughness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToughness: %w", err)
	}
	return oldValue.Toughness, nil
}

// ResetToughness resets all changes to the "toughness" field.
func (m *CardMutation) ResetToughness() {
	m.toughness = nil
}

// SetImageURL sets the "image_url" field.
func (m *CardMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *CardMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *CardMutation) ResetImageURL() {
	m.image_url = nil
}

// SetOriginalText sets the "original_text" field.
func (m *CardMutation) SetOriginalText(s string) {
	m.original_text = &s
}

// OriginalText returns the value of the "original_text" field in the mutation.
func (m *CardMutation) OriginalText() (r string, exists bool) {
	v := m.original_text
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalText returns the old "original_text" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldOriginalText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalText: %w", err)
	}
	return oldValue.OriginalText, nil
}

// ResetOriginalText resets all changes to the "original_text" field.
func (m *CardMutation) ResetOriginalText() {
	m.original_text = nil
}

// SetOriginalType sets the "original_type" field.
func (m *CardMutation) SetOriginalType(s string) {
	m.original_type = &s
}

// OriginalType returns the value of the "original_type" field in the mutation.
func (m *CardMutation) OriginalType() (r string, exists bool) {
	v := m.original_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalType returns the old "original_type" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldOriginalType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalType: %w", err)
	}
	return oldValue.OriginalType, nil
}

// ResetOriginalType resets all changes to the "original_type" field.
func (m *CardMutation) ResetOriginalType() {
	m.original_type = nil
}

// SetCachedImagePath sets the "cached_image_path" field.
func (m *CardMutation) SetCachedImagePath(s string) {
	m.cached_image_path = &s
}

// CachedImagePath returns the value of the "cached_image_path" field in the mutation.
func (m *CardMutation) CachedImagePath() (r string, exists bool) {
	v := m.cached_image_path
	if v == nil {
		return
	}
	return *v, true
}

// OldCachedImagePath returns the old "cached_image_path" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldCachedImagePath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCachedImagePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCachedImagePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCachedImagePath: %w", err)
	}
	return oldValue.CachedImagePath, nil
}

// ClearCachedImagePath clears the value of the "cached_image_path" field.
func (m *CardMutation) ClearCachedImagePath() {
	m.cached_image_path = nil
	m.clearedFields[card.FieldCachedImagePath] = struct{}{}
}

// CachedImagePathCleared returns if the "cached_image_path" field was cleared in this mutation.
func (m *CardMutation) CachedImagePathCleared() bool {
	_, ok := m.clearedFields[card.FieldCachedImagePath]
	return ok
}

// ResetCachedImagePath resets all changes to the "cached_image_path" field.
func (m *CardMutation) ResetCachedImagePath() {
	m.cached_image_path = nil
	delete(m.clearedFields, card.FieldCachedImagePath)
}

// SetRarity sets the "rarity" field.
func (m *CardMutation) SetRarity(s string) {
	m.rarity = &s
}

// Rarity returns the value of the "rarity" field in the mutation.
func (m *CardMutation) Rarity() (r string, exists bool) {
	v := m.rarity
	if v == nil {
		return
	}
	return *v, true
}

// OldRarity returns the old "rarity" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldRarity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRarity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRarity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRarity: %w", err)
	}
	return oldValue.Rarity, nil
}

// ResetRarity resets all changes to the "rarity" field.
func (m *CardMutation) ResetRarity() {
	m.rarity = nil
}

// AddRulingIDs adds the "rulings" edge to the Ruling entity by ids.
func (m *CardMutation) AddRulingIDs(ids ...int) {
	if m.rulings == nil {
		m.rulings = make(map[int]struct{})
	}
	for i := range ids {
		m.rulings[ids[i]] = struct{}{}
	}
}

// ClearRulings clears the "rulings" edge to the Ruling entity.
func (m *CardMutation) ClearRulings() {
	m.clearedrulings = true
}

// RulingsCleared reports if the "rulings" edge to the Ruling entity was cleared.
func (m *CardMutation) RulingsCleared() bool {
	return m.clearedrulings
}

// RemoveRulingIDs removes the "rulings" edge to the Ruling entity by IDs.
func (m *CardMutation) RemoveRulingIDs(ids ...int) {
	if m.removedrulings == nil {
		m.removedrulings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rulings, ids[i])
		m.removedrulings[ids[i]] = struct{}{}
	}
}

// RemovedRulings returns the removed IDs of the "rulings" edge to the Ruling entity.
func (m *CardMutation) RemovedRulingsIDs() (ids []int) {
	for id := range m.removedrulings {
		ids = append(ids, id)
	}
	return
}

// RulingsIDs returns the "rulings" edge IDs in the mutation.
func (m *CardMutation) RulingsIDs() (ids []int) {
	for id := range m.rulings {
		ids = append(ids, id)
	}
	return
}

// ResetRulings resets all changes to the "rulings" edge.
func (m *CardMutation) ResetRulings() {
	m.rulings = nil
	m.clearedrulings = false
	m.removedrulings = nil
}

// SetSetID sets the "set" edge to the Set entity by id.
func (m *CardMutation) SetSetID(id int) {
	m.set = &id
}

// ClearSet clears the "set" edge to the Set entity.
func (m *CardMutation) ClearSet() {
	m.clearedset = true
}

// SetCleared reports if the "set" edge to the Set entity was cleared.
func (m *CardMutation) SetCleared() bool {
	return m.clearedset
}

// SetID returns the "set" edge ID in the mutation.
func (m *CardMutation) SetID() (id int, exists bool) {
	if m.set != nil {
		return *m.set, true
	}
	return
}

// SetIDs returns the "set" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SetID instead. It exists only for internal usage by the builders.
func (m *CardMutation) SetIDs() (ids []int) {
	if id := m.set; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSet resets all changes to the "set" edge.
func (m *CardMutation) ResetSet() {
	m.set = nil
	m.clearedset = false
}

// AddTypeIDs adds the "types" edge to the CardType entity by ids.
func (m *CardMutation) AddTypeIDs(ids ...int) {
	if m.types == nil {
		m.types = make(map[int]struct{})
	}
	for i := range ids {
		m.types[ids[i]] = struct{}{}
	}
}

// ClearTypes clears the "types" edge to the CardType entity.
func (m *CardMutation) ClearTypes() {
	m.clearedtypes = true
}

// TypesCleared reports if the "types" edge to the CardType entity was cleared.
func (m *CardMutation) TypesCleared() bool {
	return m.clearedtypes
}

// RemoveTypeIDs removes the "types" edge to the CardType entity by IDs.
func (m *CardMutation) RemoveTypeIDs(ids ...int) {
	if m.removedtypes == nil {
		m.removedtypes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.types, ids[i])
		m.removedtypes[ids[i]] = struct{}{}
	}
}

// RemovedTypes returns the removed IDs of the "types" edge to the CardType entity.
func (m *CardMutation) RemovedTypesIDs() (ids []int) {
	for id := range m.removedtypes {
		ids = append(ids, id)
	}
	return
}

// TypesIDs returns the "types" edge IDs in the mutation.
func (m *CardMutation) TypesIDs() (ids []int) {
	for id := range m.types {
		ids = append(ids, id)
	}
	return
}

// ResetTypes resets all changes to the "types" edge.
func (m *CardMutation) ResetTypes() {
	m.types = nil
	m.clearedtypes = false
	m.removedtypes = nil
}

// AddSubtypeIDs adds the "subtypes" edge to the SubType entity by ids.
func (m *CardMutation) AddSubtypeIDs(ids ...int) {
	if m.subtypes == nil {
		m.subtypes = make(map[int]struct{})
	}
	for i := range ids {
		m.subtypes[ids[i]] = struct{}{}
	}
}

// ClearSubtypes clears the "subtypes" edge to the SubType entity.
func (m *CardMutation) ClearSubtypes() {
	m.clearedsubtypes = true
}

// SubtypesCleared reports if the "subtypes" edge to the SubType entity was cleared.
func (m *CardMutation) SubtypesCleared() bool {
	return m.clearedsubtypes
}

// RemoveSubtypeIDs removes the "subtypes" edge to the SubType entity by IDs.
func (m *CardMutation) RemoveSubtypeIDs(ids ...int) {
	if m.removedsubtypes == nil {
		m.removedsubtypes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subtypes, ids[i])
		m.removedsubtypes[ids[i]] = struct{}{}
	}
}

// RemovedSubtypes returns the removed IDs of the "subtypes" edge to the SubType entity.
func (m *CardMutation) RemovedSubtypesIDs() (ids []int) {
	for id := range m.removedsubtypes {
		ids = append(ids, id)
	}
	return
}

// SubtypesIDs returns the "subtypes" edge IDs in the mutation.
func (m *CardMutation) SubtypesIDs() (ids []int) {
	for id := range m.subtypes {
		ids = append(ids, id)
	}
	return
}

// ResetSubtypes resets all changes to the "subtypes" edge.
func (m *CardMutation) ResetSubtypes() {
	m.subtypes = nil
	m.clearedsubtypes = false
	m.removedsubtypes = nil
}

// AddSupertypeIDs adds the "supertypes" edge to the SuperType entity by ids.
func (m *CardMutation) AddSupertypeIDs(ids ...int) {
	if m.supertypes == nil {
		m.supertypes = make(map[int]struct{})
	}
	for i := range ids {
		m.supertypes[ids[i]] = struct{}{}
	}
}

// ClearSupertypes clears the "supertypes" edge to the SuperType entity.
func (m *CardMutation) ClearSupertypes() {
	m.clearedsupertypes = true
}

// SupertypesCleared reports if the "supertypes" edge to the SuperType entity was cleared.
func (m *CardMutation) SupertypesCleared() bool {
	return m.clearedsupertypes
}

// RemoveSupertypeIDs removes the "supertypes" edge to the SuperType entity by IDs.
func (m *CardMutation) RemoveSupertypeIDs(ids ...int) {
	if m.removedsupertypes == nil {
		m.removedsupertypes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.supertypes, ids[i])
		m.removedsupertypes[ids[i]] = struct{}{}
	}
}

// RemovedSupertypes returns the removed IDs of the "supertypes" edge to the SuperType entity.
func (m *CardMutation) RemovedSupertypesIDs() (ids []int) {
	for id := range m.removedsupertypes {
		ids = append(ids, id)
	}
	return
}

// SupertypesIDs returns the "supertypes" edge IDs in the mutation.
func (m *CardMutation) SupertypesIDs() (ids []int) {
	for id := range m.supertypes {
		ids = append(ids, id)
	}
	return
}

// ResetSupertypes resets all changes to the "supertypes" edge.
func (m *CardMutation) ResetSupertypes() {
	m.supertypes = nil
	m.clearedsupertypes = false
	m.removedsupertypes = nil
}

// AddColorIDs adds the "colors" edge to the Color entity by ids.
func (m *CardMutation) AddColorIDs(ids ...int) {
	if m.colors == nil {
		m.colors = make(map[int]struct{})
	}
	for i := range ids {
		m.colors[ids[i]] = struct{}{}
	}
}

// ClearColors clears the "colors" edge to the Color entity.
func (m *CardMutation) ClearColors() {
	m.clearedcolors = true
}

// ColorsCleared reports if the "colors" edge to the Color entity was cleared.
func (m *CardMutation) ColorsCleared() bool {
	return m.clearedcolors
}

// RemoveColorIDs removes the "colors" edge to the Color entity by IDs.
func (m *CardMutation) RemoveColorIDs(ids ...int) {
	if m.removedcolors == nil {
		m.removedcolors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.colors, ids[i])
		m.removedcolors[ids[i]] = struct{}{}
	}
}

// RemovedColors returns the removed IDs of the "colors" edge to the Color entity.
func (m *CardMutation) RemovedColorsIDs() (ids []int) {
	for id := range m.removedcolors {
		ids = append(ids, id)
	}
	return
}

// ColorsIDs returns the "colors" edge IDs in the mutation.
func (m *CardMutation) ColorsIDs() (ids []int) {
	for id := range m.colors {
		ids = append(ids, id)
	}
	return
}

// ResetColors resets all changes to the "colors" edge.
func (m *CardMutation) ResetColors() {
	m.colors = nil
	m.clearedcolors = false
	m.removedcolors = nil
}

// AddDeckCardIDs adds the "deck_cards" edge to the DeckCard entity by ids.
func (m *CardMutation) AddDeckCardIDs(ids ...int) {
	if m.deck_cards == nil {
		m.deck_cards = make(map[int]struct{})
	}
	for i := range ids {
		m.deck_cards[ids[i]] = struct{}{}
	}
}

// ClearDeckCards clears the "deck_cards" edge to the DeckCard entity.
func (m *CardMutation) ClearDeckCards() {
	m.cleareddeck_cards = true
}

// DeckCardsCleared reports if the "deck_cards" edge to the DeckCard entity was cleared.
func (m *CardMutation) DeckCardsCleared() bool {
	return m.cleareddeck_cards
}

// RemoveDeckCardIDs removes the "deck_cards" edge to the DeckCard entity by IDs.
func (m *CardMutation) RemoveDeckCardIDs(ids ...int) {
	if m.removeddeck_cards == nil {
		m.removeddeck_cards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deck_cards, ids[i])
		m.removeddeck_cards[ids[i]] = struct{}{}
	}
}

// RemovedDeckCards returns the removed IDs of the "deck_cards" edge to the DeckCard entity.
func (m *CardMutation) RemovedDeckCardsIDs() (ids []int) {
	for id := range m.removeddeck_cards {
		ids = append(ids, id)
	}
	return
}

// DeckCardsIDs returns the "deck_cards" edge IDs in the mutation.
func (m *CardMutation) DeckCardsIDs() (ids []int) {
	for id := range m.deck_cards {
		ids = append(ids, id)
	}
	return
}

// ResetDeckCards resets all changes to the "deck_cards" edge.
func (m *CardMutation) ResetDeckCards() {
	m.deck_cards = nil
	m.cleareddeck_cards = false
	m.removeddeck_cards = nil
}

// Where appends a list predicates to the CardMutation builder.
func (m *CardMutation) Where(ps ...predicate.Card) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CardMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Card).
func (m *CardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.multiverse_id != nil {
		fields = append(fields, card.FieldMultiverseID)
	}
	if m.gatherer_id != nil {
		fields = append(fields, card.FieldGathererID)
	}
	if m.name != nil {
		fields = append(fields, card.FieldName)
	}
	if m._type != nil {
		fields = append(fields, card.FieldType)
	}
	if m.text != nil {
		fields = append(fields, card.FieldText)
	}
	if m.cmc != nil {
		fields = append(fields, card.FieldCmc)
	}
	if m.mana_cost != nil {
		fields = append(fields, card.FieldManaCost)
	}
	if m.artist != nil {
		fields = append(fields, card.FieldArtist)
	}
	if m.power != nil {
		fields = append(fields, card.FieldPower)
	}
	if m.toughness != nil {
		fields = append(fields, card.FieldToughness)
	}
	if m.image_url != nil {
		fields = append(fields, card.FieldImageURL)
	}
	if m.original_text != nil {
		fields = append(fields, card.FieldOriginalText)
	}
	if m.original_type != nil {
		fields = append(fields, card.FieldOriginalType)
	}
	if m.cached_image_path != nil {
		fields = append(fields, card.FieldCachedImagePath)
	}
	if m.rarity != nil {
		fields = append(fields, card.FieldRarity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case card.FieldMultiverseID:
		return m.MultiverseID()
	case card.FieldGathererID:
		return m.GathererID()
	case card.FieldName:
		return m.Name()
	case card.FieldType:
		return m.GetType()
	case card.FieldText:
		return m.Text()
	case card.FieldCmc:
		return m.Cmc()
	case card.FieldManaCost:
		return m.ManaCost()
	case card.FieldArtist:
		return m.Artist()
	case card.FieldPower:
		return m.Power()
	case card.FieldToughness:
		return m.Toughness()
	case card.FieldImageURL:
		return m.ImageURL()
	case card.FieldOriginalText:
		return m.OriginalText()
	case card.FieldOriginalType:
		return m.OriginalType()
	case card.FieldCachedImagePath:
		return m.CachedImagePath()
	case card.FieldRarity:
		return m.Rarity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case card.FieldMultiverseID:
		return m.OldMultiverseID(ctx)
	case card.FieldGathererID:
		return m.OldGathererID(ctx)
	case card.FieldName:
		return m.OldName(ctx)
	case card.FieldType:
		return m.OldType(ctx)
	case card.FieldText:
		return m.OldText(ctx)
	case card.FieldCmc:
		return m.OldCmc(ctx)
	case card.FieldManaCost:
		return m.OldManaCost(ctx)
	case card.FieldArtist:
		return m.OldArtist(ctx)
	case card.FieldPower:
		return m.OldPower(ctx)
	case card.FieldToughness:
		return m.OldToughness(ctx)
	case card.FieldImageURL:
		return m.OldImageURL(ctx)
	case card.FieldOriginalText:
		return m.OldOriginalText(ctx)
	case card.FieldOriginalType:
		return m.OldOriginalType(ctx)
	case card.FieldCachedImagePath:
		return m.OldCachedImagePath(ctx)
	case card.FieldRarity:
		return m.OldRarity(ctx)
	}
	return nil, fmt.Errorf("unknown Card field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case card.FieldMultiverseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiverseID(v)
		return nil
	case card.FieldGathererID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGathererID(v)
		return nil
	case card.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case card.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case card.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case card.FieldCmc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmc(v)
		return nil
	case card.FieldManaCost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManaCost(v)
		return nil
	case card.FieldArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtist(v)
		return nil
	case card.FieldPower:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPower(v)
		return nil
	case card.FieldToughness:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToughness(v)
		return nil
	case card.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case card.FieldOriginalText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalText(v)
		return nil
	case card.FieldOriginalType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalType(v)
		return nil
	case card.FieldCachedImagePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCachedImagePath(v)
		return nil
	case card.FieldRarity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRarity(v)
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardMutation) AddedFields() []string {
	var fields []string
	if m.addcmc != nil {
		fields = append(fields, card.FieldCmc)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case card.FieldCmc:
		return m.AddedCmc()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case card.FieldCmc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCmc(v)
		return nil
	}
	return fmt.Errorf("unknown Card numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(card.FieldCachedImagePath) {
		fields = append(fields, card.FieldCachedImagePath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardMutation) ClearField(name string) error {
	switch name {
	case card.FieldCachedImagePath:
		m.ClearCachedImagePath()
		return nil
	}
	return fmt.Errorf("unknown Card nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardMutation) ResetField(name string) error {
	switch name {
	case card.FieldMultiverseID:
		m.ResetMultiverseID()
		return nil
	case card.FieldGathererID:
		m.ResetGathererID()
		return nil
	case card.FieldName:
		m.ResetName()
		return nil
	case card.FieldType:
		m.ResetType()
		return nil
	case card.FieldText:
		m.ResetText()
		return nil
	case card.FieldCmc:
		m.ResetCmc()
		return nil
	case card.FieldManaCost:
		m.ResetManaCost()
		return nil
	case card.FieldArtist:
		m.ResetArtist()
		return nil
	case card.FieldPower:
		m.ResetPower()
		return nil
	case card.FieldToughness:
		m.ResetToughness()
		return nil
	case card.FieldImageURL:
		m.ResetImageURL()
		return nil
	case card.FieldOriginalText:
		m.ResetOriginalText()
		return nil
	case card.FieldOriginalType:
		m.ResetOriginalType()
		return nil
	case card.FieldCachedImagePath:
		m.ResetCachedImagePath()
		return nil
	case card.FieldRarity:
		m.ResetRarity()
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.rulings != nil {
		edges = append(edges, card.EdgeRulings)
	}
	if m.set != nil {
		edges = append(edges, card.EdgeSet)
	}
	if m.types != nil {
		edges = append(edges, card.EdgeTypes)
	}
	if m.subtypes != nil {
		edges = append(edges, card.EdgeSubtypes)
	}
	if m.supertypes != nil {
		edges = append(edges, card.EdgeSupertypes)
	}
	if m.colors != nil {
		edges = append(edges, card.EdgeColors)
	}
	if m.deck_cards != nil {
		edges = append(edges, card.EdgeDeckCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeRulings:
		ids := make([]ent.Value, 0, len(m.rulings))
		for id := range m.rulings {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeSet:
		if id := m.set; id != nil {
			return []ent.Value{*id}
		}
	case card.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.types))
		for id := range m.types {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeSubtypes:
		ids := make([]ent.Value, 0, len(m.subtypes))
		for id := range m.subtypes {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeSupertypes:
		ids := make([]ent.Value, 0, len(m.supertypes))
		for id := range m.supertypes {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeColors:
		ids := make([]ent.Value, 0, len(m.colors))
		for id := range m.colors {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeDeckCards:
		ids := make([]ent.Value, 0, len(m.deck_cards))
		for id := range m.deck_cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedrulings != nil {
		edges = append(edges, card.EdgeRulings)
	}
	if m.removedtypes != nil {
		edges = append(edges, card.EdgeTypes)
	}
	if m.removedsubtypes != nil {
		edges = append(edges, card.EdgeSubtypes)
	}
	if m.removedsupertypes != nil {
		edges = append(edges, card.EdgeSupertypes)
	}
	if m.removedcolors != nil {
		edges = append(edges, card.EdgeColors)
	}
	if m.removeddeck_cards != nil {
		edges = append(edges, card.EdgeDeckCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeRulings:
		ids := make([]ent.Value, 0, len(m.removedrulings))
		for id := range m.removedrulings {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.removedtypes))
		for id := range m.removedtypes {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeSubtypes:
		ids := make([]ent.Value, 0, len(m.removedsubtypes))
		for id := range m.removedsubtypes {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeSupertypes:
		ids := make([]ent.Value, 0, len(m.removedsupertypes))
		for id := range m.removedsupertypes {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeColors:
		ids := make([]ent.Value, 0, len(m.removedcolors))
		for id := range m.removedcolors {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeDeckCards:
		ids := make([]ent.Value, 0, len(m.removeddeck_cards))
		for id := range m.removeddeck_cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedrulings {
		edges = append(edges, card.EdgeRulings)
	}
	if m.clearedset {
		edges = append(edges, card.EdgeSet)
	}
	if m.clearedtypes {
		edges = append(edges, card.EdgeTypes)
	}
	if m.clearedsubtypes {
		edges = append(edges, card.EdgeSubtypes)
	}
	if m.clearedsupertypes {
		edges = append(edges, card.EdgeSupertypes)
	}
	if m.clearedcolors {
		edges = append(edges, card.EdgeColors)
	}
	if m.cleareddeck_cards {
		edges = append(edges, card.EdgeDeckCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardMutation) EdgeCleared(name string) bool {
	switch name {
	case card.EdgeRulings:
		return m.clearedrulings
	case card.EdgeSet:
		return m.clearedset
	case card.EdgeTypes:
		return m.clearedtypes
	case card.EdgeSubtypes:
		return m.clearedsubtypes
	case card.EdgeSupertypes:
		return m.clearedsupertypes
	case card.EdgeColors:
		return m.clearedcolors
	case card.EdgeDeckCards:
		return m.cleareddeck_cards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardMutation) ClearEdge(name string) error {
	switch name {
	case card.EdgeSet:
		m.ClearSet()
		return nil
	}
	return fmt.Errorf("unknown Card unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardMutation) ResetEdge(name string) error {
	switch name {
	case card.EdgeRulings:
		m.ResetRulings()
		return nil
	case card.EdgeSet:
		m.ResetSet()
		return nil
	case card.EdgeTypes:
		m.ResetTypes()
		return nil
	case card.EdgeSubtypes:
		m.ResetSubtypes()
		return nil
	case card.EdgeSupertypes:
		m.ResetSupertypes()
		return nil
	case card.EdgeColors:
		m.ResetColors()
		return nil
	case card.EdgeDeckCards:
		m.ResetDeckCards()
		return nil
	}
	return fmt.Errorf("unknown Card edge %s", name)
}

// CardTypeMutation represents an operation that mutates the CardType nodes in the graph.
type CardTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	cards         map[int]struct{}
	removedcards  map[int]struct{}
	clearedcards  bool
	done          bool
	oldValue      func(context.Context) (*CardType, error)
	predicates    []predicate.CardType
}

var _ ent.Mutation = (*CardTypeMutation)(nil)

// cardtypeOption allows management of the mutation configuration using functional options.
type cardtypeOption func(*CardTypeMutation)

// newCardTypeMutation creates new mutation for the CardType entity.
func newCardTypeMutation(c config, op Op, opts ...cardtypeOption) *CardTypeMutation {
	m := &CardTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCardType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardTypeID sets the ID field of the mutation.
func withCardTypeID(id int) cardtypeOption {
	return func(m *CardTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CardType
		)
		m.oldValue = func(ctx context.Context) (*CardType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CardType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCardType sets the old CardType of the mutation.
func withCardType(node *CardType) cardtypeOption {
	return func(m *CardTypeMutation) {
		m.oldValue = func(context.Context) (*CardType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CardType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CardTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CardTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CardType entity.
// If the CardType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CardTypeMutation) ResetName() {
	m.name = nil
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *CardTypeMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *CardTypeMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *CardTypeMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *CardTypeMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *CardTypeMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *CardTypeMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *CardTypeMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// Where appends a list predicates to the CardTypeMutation builder.
func (m *CardTypeMutation) Where(ps ...predicate.CardType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CardTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CardType).
func (m *CardTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cardtype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cardtype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cardtype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CardType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cardtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CardType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CardType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CardType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardTypeMutation) ResetField(name string) error {
	switch name {
	case cardtype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CardType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cards != nil {
		edges = append(edges, cardtype.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cardtype.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcards != nil {
		edges = append(edges, cardtype.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cardtype.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcards {
		edges = append(edges, cardtype.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case cardtype.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CardType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardTypeMutation) ResetEdge(name string) error {
	switch name {
	case cardtype.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown CardType edge %s", name)
}

// ColorMutation represents an operation that mutates the Color nodes in the graph.
type ColorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	code          *string
	clearedFields map[string]struct{}
	cards         map[int]struct{}
	removedcards  map[int]struct{}
	clearedcards  bool
	done          bool
	oldValue      func(context.Context) (*Color, error)
	predicates    []predicate.Color
}

var _ ent.Mutation = (*ColorMutation)(nil)

// colorOption allows management of the mutation configuration using functional options.
type colorOption func(*ColorMutation)

// newColorMutation creates new mutation for the Color entity.
func newColorMutation(c config, op Op, opts ...colorOption) *ColorMutation {
	m := &ColorMutation{
		config:        c,
		op:            op,
		typ:           TypeColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withColorID sets the ID field of the mutation.
func withColorID(id int) colorOption {
	return func(m *ColorMutation) {
		var (
			err   error
			once  sync.Once
			value *Color
		)
		m.oldValue = func(ctx context.Context) (*Color, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Color.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withColor sets the old Color of the mutation.
func withColor(node *Color) colorOption {
	return func(m *ColorMutation) {
		m.oldValue = func(context.Context) (*Color, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ColorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ColorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Color.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ColorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ColorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Color entity.
// If the Color object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ColorMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *ColorMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ColorMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Color entity.
// If the Color object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColorMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ColorMutation) ResetCode() {
	m.code = nil
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *ColorMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *ColorMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *ColorMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *ColorMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *ColorMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *ColorMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *ColorMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// Where appends a list predicates to the ColorMutation builder.
func (m *ColorMutation) Where(ps ...predicate.Color) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ColorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Color).
func (m *ColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ColorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, color.FieldName)
	}
	if m.code != nil {
		fields = append(fields, color.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case color.FieldName:
		return m.Name()
	case color.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case color.FieldName:
		return m.OldName(ctx)
	case color.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Color field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case color.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case color.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Color field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ColorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ColorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Color numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ColorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ColorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Color nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ColorMutation) ResetField(name string) error {
	switch name {
	case color.FieldName:
		m.ResetName()
		return nil
	case color.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Color field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cards != nil {
		edges = append(edges, color.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ColorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case color.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcards != nil {
		edges = append(edges, color.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ColorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case color.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcards {
		edges = append(edges, color.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ColorMutation) EdgeCleared(name string) bool {
	switch name {
	case color.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ColorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Color unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ColorMutation) ResetEdge(name string) error {
	switch name {
	case color.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown Color edge %s", name)
}

// DeckMutation represents an operation that mutates the Deck nodes in the graph.
type DeckMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	clearedFields map[string]struct{}
	cards         map[int]struct{}
	removedcards  map[int]struct{}
	clearedcards  bool
	done          bool
	oldValue      func(context.Context) (*Deck, error)
	predicates    []predicate.Deck
}

var _ ent.Mutation = (*DeckMutation)(nil)

// deckOption allows management of the mutation configuration using functional options.
type deckOption func(*DeckMutation)

// newDeckMutation creates new mutation for the Deck entity.
func newDeckMutation(c config, op Op, opts ...deckOption) *DeckMutation {
	m := &DeckMutation{
		config:        c,
		op:            op,
		typ:           TypeDeck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeckID sets the ID field of the mutation.
func withDeckID(id int) deckOption {
	return func(m *DeckMutation) {
		var (
			err   error
			once  sync.Once
			value *Deck
		)
		m.oldValue = func(ctx context.Context) (*Deck, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deck.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeck sets the old Deck of the mutation.
func withDeck(node *Deck) deckOption {
	return func(m *DeckMutation) {
		m.oldValue = func(context.Context) (*Deck, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeckMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeckMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Deck.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DeckMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeckMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeckMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DeckMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeckMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DeckMutation) ResetDescription() {
	m.description = nil
}

// AddCardIDs adds the "cards" edge to the DeckCard entity by ids.
func (m *DeckMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the DeckCard entity.
func (m *DeckMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the DeckCard entity was cleared.
func (m *DeckMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the DeckCard entity by IDs.
func (m *DeckMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the DeckCard entity.
func (m *DeckMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *DeckMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *DeckMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// Where appends a list predicates to the DeckMutation builder.
func (m *DeckMutation) Where(ps ...predicate.Deck) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeckMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Deck).
func (m *DeckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeckMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, deck.FieldName)
	}
	if m.description != nil {
		fields = append(fields, deck.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deck.FieldName:
		return m.Name()
	case deck.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deck.FieldName:
		return m.OldName(ctx)
	case deck.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Deck field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deck.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deck.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Deck field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeckMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeckMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deck numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeckMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeckMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Deck nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeckMutation) ResetField(name string) error {
	switch name {
	case deck.FieldName:
		m.ResetName()
		return nil
	case deck.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Deck field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeckMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cards != nil {
		edges = append(edges, deck.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeckMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deck.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcards != nil {
		edges = append(edges, deck.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeckMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deck.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcards {
		edges = append(edges, deck.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeckMutation) EdgeCleared(name string) bool {
	switch name {
	case deck.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeckMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Deck unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeckMutation) ResetEdge(name string) error {
	switch name {
	case deck.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown Deck edge %s", name)
}

// DeckCardMutation represents an operation that mutates the DeckCard nodes in the graph.
type DeckCardMutation struct {
	config
	op            Op
	typ           string
	id            *int
	count         *int
	addcount      *int
	clearedFields map[string]struct{}
	deck          *int
	cleareddeck   bool
	card          *int
	clearedcard   bool
	done          bool
	oldValue      func(context.Context) (*DeckCard, error)
	predicates    []predicate.DeckCard
}

var _ ent.Mutation = (*DeckCardMutation)(nil)

// deckcardOption allows management of the mutation configuration using functional options.
type deckcardOption func(*DeckCardMutation)

// newDeckCardMutation creates new mutation for the DeckCard entity.
func newDeckCardMutation(c config, op Op, opts ...deckcardOption) *DeckCardMutation {
	m := &DeckCardMutation{
		config:        c,
		op:            op,
		typ:           TypeDeckCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeckCardID sets the ID field of the mutation.
func withDeckCardID(id int) deckcardOption {
	return func(m *DeckCardMutation) {
		var (
			err   error
			once  sync.Once
			value *DeckCard
		)
		m.oldValue = func(ctx context.Context) (*DeckCard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeckCard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeckCard sets the old DeckCard of the mutation.
func withDeckCard(node *DeckCard) deckcardOption {
	return func(m *DeckCardMutation) {
		m.oldValue = func(context.Context) (*DeckCard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeckCardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeckCardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeckCardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeckCardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeckCard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCount sets the "count" field.
func (m *DeckCardMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *DeckCardMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the DeckCard entity.
// If the DeckCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckCardMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *DeckCardMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *DeckCardMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *DeckCardMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetDeckID sets the "deck" edge to the Deck entity by id.
func (m *DeckCardMutation) SetDeckID(id int) {
	m.deck = &id
}

// ClearDeck clears the "deck" edge to the Deck entity.
func (m *DeckCardMutation) ClearDeck() {
	m.cleareddeck = true
}

// DeckCleared reports if the "deck" edge to the Deck entity was cleared.
func (m *DeckCardMutation) DeckCleared() bool {
	return m.cleareddeck
}

// DeckID returns the "deck" edge ID in the mutation.
func (m *DeckCardMutation) DeckID() (id int, exists bool) {
	if m.deck != nil {
		return *m.deck, true
	}
	return
}

// DeckIDs returns the "deck" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeckID instead. It exists only for internal usage by the builders.
func (m *DeckCardMutation) DeckIDs() (ids []int) {
	if id := m.deck; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeck resets all changes to the "deck" edge.
func (m *DeckCardMutation) ResetDeck() {
	m.deck = nil
	m.cleareddeck = false
}

// SetCardID sets the "card" edge to the Card entity by id.
func (m *DeckCardMutation) SetCardID(id int) {
	m.card = &id
}

// ClearCard clears the "card" edge to the Card entity.
func (m *DeckCardMutation) ClearCard() {
	m.clearedcard = true
}

// CardCleared reports if the "card" edge to the Card entity was cleared.
func (m *DeckCardMutation) CardCleared() bool {
	return m.clearedcard
}

// CardID returns the "card" edge ID in the mutation.
func (m *DeckCardMutation) CardID() (id int, exists bool) {
	if m.card != nil {
		return *m.card, true
	}
	return
}

// CardIDs returns the "card" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardID instead. It exists only for internal usage by the builders.
func (m *DeckCardMutation) CardIDs() (ids []int) {
	if id := m.card; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCard resets all changes to the "card" edge.
func (m *DeckCardMutation) ResetCard() {
	m.card = nil
	m.clearedcard = false
}

// Where appends a list predicates to the DeckCardMutation builder.
func (m *DeckCardMutation) Where(ps ...predicate.DeckCard) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeckCardMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeckCard).
func (m *DeckCardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeckCardMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.count != nil {
		fields = append(fields, deckcard.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeckCardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deckcard.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeckCardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deckcard.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown DeckCard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckCardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deckcard.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown DeckCard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeckCardMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, deckcard.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeckCardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deckcard.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckCardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deckcard.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown DeckCard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeckCardMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeckCardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeckCardMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeckCard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeckCardMutation) ResetField(name string) error {
	switch name {
	case deckcard.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown DeckCard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeckCardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.deck != nil {
		edges = append(edges, deckcard.EdgeDeck)
	}
	if m.card != nil {
		edges = append(edges, deckcard.EdgeCard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeckCardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deckcard.EdgeDeck:
		if id := m.deck; id != nil {
			return []ent.Value{*id}
		}
	case deckcard.EdgeCard:
		if id := m.card; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeckCardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeckCardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeckCardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeck {
		edges = append(edges, deckcard.EdgeDeck)
	}
	if m.clearedcard {
		edges = append(edges, deckcard.EdgeCard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeckCardMutation) EdgeCleared(name string) bool {
	switch name {
	case deckcard.EdgeDeck:
		return m.cleareddeck
	case deckcard.EdgeCard:
		return m.clearedcard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeckCardMutation) ClearEdge(name string) error {
	switch name {
	case deckcard.EdgeDeck:
		m.ClearDeck()
		return nil
	case deckcard.EdgeCard:
		m.ClearCard()
		return nil
	}
	return fmt.Errorf("unknown DeckCard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeckCardMutation) ResetEdge(name string) error {
	switch name {
	case deckcard.EdgeDeck:
		m.ResetDeck()
		return nil
	case deckcard.EdgeCard:
		m.ResetCard()
		return nil
	}
	return fmt.Errorf("unknown DeckCard edge %s", name)
}

// RulingMutation represents an operation that mutates the Ruling nodes in the graph.
type RulingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	text          *string
	date          *time.Time
	clearedFields map[string]struct{}
	card          *int
	clearedcard   bool
	done          bool
	oldValue      func(context.Context) (*Ruling, error)
	predicates    []predicate.Ruling
}

var _ ent.Mutation = (*RulingMutation)(nil)

// rulingOption allows management of the mutation configuration using functional options.
type rulingOption func(*RulingMutation)

// newRulingMutation creates new mutation for the Ruling entity.
func newRulingMutation(c config, op Op, opts ...rulingOption) *RulingMutation {
	m := &RulingMutation{
		config:        c,
		op:            op,
		typ:           TypeRuling,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRulingID sets the ID field of the mutation.
func withRulingID(id int) rulingOption {
	return func(m *RulingMutation) {
		var (
			err   error
			once  sync.Once
			value *Ruling
		)
		m.oldValue = func(ctx context.Context) (*Ruling, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ruling.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRuling sets the old Ruling of the mutation.
func withRuling(node *Ruling) rulingOption {
	return func(m *RulingMutation) {
		m.oldValue = func(context.Context) (*Ruling, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RulingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RulingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RulingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RulingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ruling.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *RulingMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *RulingMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Ruling entity.
// If the Ruling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulingMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *RulingMutation) ResetText() {
	m.text = nil
}

// SetDate sets the "date" field.
func (m *RulingMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *RulingMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Ruling entity.
// If the Ruling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulingMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *RulingMutation) ResetDate() {
	m.date = nil
}

// SetCardID sets the "card" edge to the Card entity by id.
func (m *RulingMutation) SetCardID(id int) {
	m.card = &id
}

// ClearCard clears the "card" edge to the Card entity.
func (m *RulingMutation) ClearCard() {
	m.clearedcard = true
}

// CardCleared reports if the "card" edge to the Card entity was cleared.
func (m *RulingMutation) CardCleared() bool {
	return m.clearedcard
}

// CardID returns the "card" edge ID in the mutation.
func (m *RulingMutation) CardID() (id int, exists bool) {
	if m.card != nil {
		return *m.card, true
	}
	return
}

// CardIDs returns the "card" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardID instead. It exists only for internal usage by the builders.
func (m *RulingMutation) CardIDs() (ids []int) {
	if id := m.card; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCard resets all changes to the "card" edge.
func (m *RulingMutation) ResetCard() {
	m.card = nil
	m.clearedcard = false
}

// Where appends a list predicates to the RulingMutation builder.
func (m *RulingMutation) Where(ps ...predicate.Ruling) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RulingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ruling).
func (m *RulingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RulingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.text != nil {
		fields = append(fields, ruling.FieldText)
	}
	if m.date != nil {
		fields = append(fields, ruling.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RulingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ruling.FieldText:
		return m.Text()
	case ruling.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RulingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ruling.FieldText:
		return m.OldText(ctx)
	case ruling.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Ruling field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RulingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ruling.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case ruling.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Ruling field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RulingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RulingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RulingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ruling numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RulingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RulingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RulingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ruling nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RulingMutation) ResetField(name string) error {
	switch name {
	case ruling.FieldText:
		m.ResetText()
		return nil
	case ruling.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Ruling field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RulingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.card != nil {
		edges = append(edges, ruling.EdgeCard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RulingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ruling.EdgeCard:
		if id := m.card; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RulingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RulingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RulingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcard {
		edges = append(edges, ruling.EdgeCard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RulingMutation) EdgeCleared(name string) bool {
	switch name {
	case ruling.EdgeCard:
		return m.clearedcard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RulingMutation) ClearEdge(name string) error {
	switch name {
	case ruling.EdgeCard:
		m.ClearCard()
		return nil
	}
	return fmt.Errorf("unknown Ruling unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RulingMutation) ResetEdge(name string) error {
	switch name {
	case ruling.EdgeCard:
		m.ResetCard()
		return nil
	}
	return fmt.Errorf("unknown Ruling edge %s", name)
}

// SetMutation represents an operation that mutates the Set nodes in the graph.
type SetMutation struct {
	config
	op            Op
	typ           string
	id            *int
	code          *string
	name          *string
	_type         *string
	border        *string
	release_date  *string
	clearedFields map[string]struct{}
	cards         map[int]struct{}
	removedcards  map[int]struct{}
	clearedcards  bool
	done          bool
	oldValue      func(context.Context) (*Set, error)
	predicates    []predicate.Set
}

var _ ent.Mutation = (*SetMutation)(nil)

// setOption allows management of the mutation configuration using functional options.
type setOption func(*SetMutation)

// newSetMutation creates new mutation for the Set entity.
func newSetMutation(c config, op Op, opts ...setOption) *SetMutation {
	m := &SetMutation{
		config:        c,
		op:            op,
		typ:           TypeSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSetID sets the ID field of the mutation.
func withSetID(id int) setOption {
	return func(m *SetMutation) {
		var (
			err   error
			once  sync.Once
			value *Set
		)
		m.oldValue = func(ctx context.Context) (*Set, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Set.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSet sets the old Set of the mutation.
func withSet(node *Set) setOption {
	return func(m *SetMutation) {
		m.oldValue = func(context.Context) (*Set, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Set.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *SetMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SetMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *SetMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *SetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SetMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *SetMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SetMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SetMutation) ResetType() {
	m._type = nil
}

// SetBorder sets the "border" field.
func (m *SetMutation) SetBorder(s string) {
	m.border = &s
}

// Border returns the value of the "border" field in the mutation.
func (m *SetMutation) Border() (r string, exists bool) {
	v := m.border
	if v == nil {
		return
	}
	return *v, true
}

// OldBorder returns the old "border" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldBorder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBorder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBorder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBorder: %w", err)
	}
	return oldValue.Border, nil
}

// ResetBorder resets all changes to the "border" field.
func (m *SetMutation) ResetBorder() {
	m.border = nil
}

// SetReleaseDate sets the "release_date" field.
func (m *SetMutation) SetReleaseDate(s string) {
	m.release_date = &s
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *SetMutation) ReleaseDate() (r string, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the Set entity.
// If the Set object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SetMutation) OldReleaseDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *SetMutation) ResetReleaseDate() {
	m.release_date = nil
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *SetMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *SetMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *SetMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *SetMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *SetMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *SetMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *SetMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// Where appends a list predicates to the SetMutation builder.
func (m *SetMutation) Where(ps ...predicate.Set) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Set).
func (m *SetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SetMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.code != nil {
		fields = append(fields, set.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, set.FieldName)
	}
	if m._type != nil {
		fields = append(fields, set.FieldType)
	}
	if m.border != nil {
		fields = append(fields, set.FieldBorder)
	}
	if m.release_date != nil {
		fields = append(fields, set.FieldReleaseDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case set.FieldCode:
		return m.Code()
	case set.FieldName:
		return m.Name()
	case set.FieldType:
		return m.GetType()
	case set.FieldBorder:
		return m.Border()
	case set.FieldReleaseDate:
		return m.ReleaseDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case set.FieldCode:
		return m.OldCode(ctx)
	case set.FieldName:
		return m.OldName(ctx)
	case set.FieldType:
		return m.OldType(ctx)
	case set.FieldBorder:
		return m.OldBorder(ctx)
	case set.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	}
	return nil, fmt.Errorf("unknown Set field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case set.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case set.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case set.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case set.FieldBorder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBorder(v)
		return nil
	case set.FieldReleaseDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Set numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Set nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SetMutation) ResetField(name string) error {
	switch name {
	case set.FieldCode:
		m.ResetCode()
		return nil
	case set.FieldName:
		m.ResetName()
		return nil
	case set.FieldType:
		m.ResetType()
		return nil
	case set.FieldBorder:
		m.ResetBorder()
		return nil
	case set.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	}
	return fmt.Errorf("unknown Set field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cards != nil {
		edges = append(edges, set.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcards != nil {
		edges = append(edges, set.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case set.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcards {
		edges = append(edges, set.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SetMutation) EdgeCleared(name string) bool {
	switch name {
	case set.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Set unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SetMutation) ResetEdge(name string) error {
	switch name {
	case set.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown Set edge %s", name)
}

// SubTypeMutation represents an operation that mutates the SubType nodes in the graph.
type SubTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	cards         map[int]struct{}
	removedcards  map[int]struct{}
	clearedcards  bool
	done          bool
	oldValue      func(context.Context) (*SubType, error)
	predicates    []predicate.SubType
}

var _ ent.Mutation = (*SubTypeMutation)(nil)

// subtypeOption allows management of the mutation configuration using functional options.
type subtypeOption func(*SubTypeMutation)

// newSubTypeMutation creates new mutation for the SubType entity.
func newSubTypeMutation(c config, op Op, opts ...subtypeOption) *SubTypeMutation {
	m := &SubTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSubType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubTypeID sets the ID field of the mutation.
func withSubTypeID(id int) subtypeOption {
	return func(m *SubTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SubType
		)
		m.oldValue = func(ctx context.Context) (*SubType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubType sets the old SubType of the mutation.
func withSubType(node *SubType) subtypeOption {
	return func(m *SubTypeMutation) {
		m.oldValue = func(context.Context) (*SubType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SubTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubType entity.
// If the SubType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubTypeMutation) ResetName() {
	m.name = nil
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *SubTypeMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *SubTypeMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *SubTypeMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *SubTypeMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *SubTypeMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *SubTypeMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *SubTypeMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// Where appends a list predicates to the SubTypeMutation builder.
func (m *SubTypeMutation) Where(ps ...predicate.SubType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SubTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SubType).
func (m *SubTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, subtype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subtype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subtype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown SubType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown SubType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubTypeMutation) ResetField(name string) error {
	switch name {
	case subtype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown SubType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cards != nil {
		edges = append(edges, subtype.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subtype.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcards != nil {
		edges = append(edges, subtype.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subtype.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcards {
		edges = append(edges, subtype.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case subtype.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SubType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubTypeMutation) ResetEdge(name string) error {
	switch name {
	case subtype.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown SubType edge %s", name)
}

// SuperTypeMutation represents an operation that mutates the SuperType nodes in the graph.
type SuperTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	cards         map[int]struct{}
	removedcards  map[int]struct{}
	clearedcards  bool
	done          bool
	oldValue      func(context.Context) (*SuperType, error)
	predicates    []predicate.SuperType
}

var _ ent.Mutation = (*SuperTypeMutation)(nil)

// supertypeOption allows management of the mutation configuration using functional options.
type supertypeOption func(*SuperTypeMutation)

// newSuperTypeMutation creates new mutation for the SuperType entity.
func newSuperTypeMutation(c config, op Op, opts ...supertypeOption) *SuperTypeMutation {
	m := &SuperTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSuperType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSuperTypeID sets the ID field of the mutation.
func withSuperTypeID(id int) supertypeOption {
	return func(m *SuperTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SuperType
		)
		m.oldValue = func(ctx context.Context) (*SuperType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SuperType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSuperType sets the old SuperType of the mutation.
func withSuperType(node *SuperType) supertypeOption {
	return func(m *SuperTypeMutation) {
		m.oldValue = func(context.Context) (*SuperType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SuperTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SuperTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SuperTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SuperTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SuperType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SuperTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SuperTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SuperType entity.
// If the SuperType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuperTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SuperTypeMutation) ResetName() {
	m.name = nil
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *SuperTypeMutation) AddCardIDs(ids ...int) {
	if m.cards == nil {
		m.cards = make(map[int]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *SuperTypeMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *SuperTypeMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *SuperTypeMutation) RemoveCardIDs(ids ...int) {
	if m.removedcards == nil {
		m.removedcards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *SuperTypeMutation) RemovedCardsIDs() (ids []int) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *SuperTypeMutation) CardsIDs() (ids []int) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *SuperTypeMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// Where appends a list predicates to the SuperTypeMutation builder.
func (m *SuperTypeMutation) Where(ps ...predicate.SuperType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SuperTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SuperType).
func (m *SuperTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SuperTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, supertype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SuperTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case supertype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SuperTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case supertype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown SuperType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SuperTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case supertype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown SuperType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SuperTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SuperTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SuperTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SuperType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SuperTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SuperTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SuperTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SuperType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SuperTypeMutation) ResetField(name string) error {
	switch name {
	case supertype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown SuperType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SuperTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cards != nil {
		edges = append(edges, supertype.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SuperTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case supertype.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SuperTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcards != nil {
		edges = append(edges, supertype.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SuperTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case supertype.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SuperTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcards {
		edges = append(edges, supertype.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SuperTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case supertype.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SuperTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SuperType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SuperTypeMutation) ResetEdge(name string) error {
	switch name {
	case supertype.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown SuperType edge %s", name)
}
